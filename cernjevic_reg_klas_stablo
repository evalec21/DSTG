#GOOGLE COLLAB

#ĆELIJA 1

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import os

from sklearn.model_selection import train_test_split, cross_validate, KFold, StratifiedKFold
from sklearn.tree import DecisionTreeRegressor, DecisionTreeClassifier, plot_tree
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.metrics import accuracy_score, f1_score, confusion_matrix, ConfusionMatrixDisplay
from sklearn.inspection import permutation_importance

sns.set_theme(style="whitegrid")

OUTPUT_DIR = "faza_3_rezultati"
os.makedirs(OUTPUT_DIR, exist_ok=True)

FILE_CV_REG = os.path.join(OUTPUT_DIR, "results_cv_metric.csv")
FILE_TT_REG = os.path.join(OUTPUT_DIR, "results_train_test_metrics.csv")
FILE_IMP_REG = os.path.join(OUTPUT_DIR, "dt_permutation_importance_reg.csv")

FILE_CV_CLS = os.path.join(OUTPUT_DIR, "results_cv_classification.csv")
FILE_TT_CLS = os.path.join(OUTPUT_DIR, "results_train_test_classification.csv")
FILE_IMP_CLS = os.path.join(OUTPUT_DIR, "dt_permutation_importance_cls.csv")

def append_to_csv(data_dict, filename):
    df_new = pd.DataFrame([data_dict])
    if os.path.exists(filename):
        df_new.to_csv(filename, mode='a', header=False, index=False)
    else:
        df_new.to_csv(filename, index=False)
    print(f"--> Rezultati spremljeni u: {filename}")

print("Učitavanje podataka...")
df = sns.load_dataset("diamonds")

X_reg = df.drop(columns=['price'])
y_reg = df['price']
cat_cols_reg = X_reg.select_dtypes(include=['category', 'object']).columns.tolist()
num_cols_reg = X_reg.select_dtypes(include=['number']).columns.tolist()

prep_reg = ColumnTransformer([
    ('num', 'passthrough', num_cols_reg),
    ('cat', OneHotEncoder(handle_unknown='ignore'), cat_cols_reg)
])

X_cls = df.drop(columns=['cut'])
y_cls = df['cut']
cat_cols_cls = X_cls.select_dtypes(include=['category', 'object']).columns.tolist()
num_cols_cls = X_cls.select_dtypes(include=['number']).columns.tolist()

prep_cls = ColumnTransformer([
    ('num', 'passthrough', num_cols_cls),
    ('cat', OneHotEncoder(handle_unknown='ignore'), cat_cols_cls)
])

print("\n" + "="*50)
print("POKRETANJE REGRESIJSKE ANALIZE (Decision Tree)")
print("="*50)

dt_reg = Pipeline([('prep', prep_reg), ('model', DecisionTreeRegressor(random_state=42))])

print("1. Izvodim Cross-Validation...")
cv_reg = KFold(n_splits=5, shuffle=True, random_state=42)
scoring_reg = ['neg_root_mean_squared_error', 'neg_mean_absolute_error', 'r2']
scores_reg = cross_validate(dt_reg, X_reg, y_reg, cv=cv_reg, scoring=scoring_reg, n_jobs=-1)

reg_cv_data = {
    "model": "DecisionTree",
    "fast_mode": False,
    "rmse_mean": -scores_reg['test_neg_root_mean_squared_error'].mean(),
    "rmse_std": scores_reg['test_neg_root_mean_squared_error'].std(),
    "mae_mean": -scores_reg['test_neg_mean_absolute_error'].mean(),
    "mae_std": scores_reg['test_neg_mean_absolute_error'].std(),
    "r2_mean": scores_reg['test_r2'].mean(),
    "r2_std": scores_reg['test_r2'].std()
}
append_to_csv(reg_cv_data, FILE_CV_REG)

print("2. Izvodim Train/Test analizu...")
X_tr_r, X_te_r, y_tr_r, y_te_r = train_test_split(X_reg, y_reg, test_size=0.2, random_state=42)
dt_reg.fit(X_tr_r, y_tr_r)

y_pred_tr = dt_reg.predict(X_tr_r)
y_pred_te = dt_reg.predict(X_te_r)

reg_tt_data = {
    "model": "DecisionTree",
    "train_rmse": np.sqrt(mean_squared_error(y_tr_r, y_pred_tr)),
    "test_rmse": np.sqrt(mean_squared_error(y_te_r, y_pred_te)),
    "train_mae": mean_absolute_error(y_tr_r, y_pred_tr),
    "test_mae": mean_absolute_error(y_te_r, y_pred_te),
    "train_r2": r2_score(y_tr_r, y_pred_tr),
    "test_r2": r2_score(y_te_r, y_pred_te)
}
append_to_csv(reg_tt_data, FILE_TT_REG)

labels = ['RMSE', 'MAE']
train_vals = [reg_tt_data['train_rmse'], reg_tt_data['train_mae']]
test_vals = [reg_tt_data['test_rmse'], reg_tt_data['test_mae']]
x = np.arange(len(labels))
width = 0.35

fig, ax = plt.subplots(figsize=(8, 6))
rects1 = ax.bar(x - width/2, train_vals, width, label='Train')
rects2 = ax.bar(x + width/2, test_vals, width, label='Test')
ax.set_ylabel('Vrijednost')
ax.set_title('Regresija: Overfitting Analiza (Decision Tree)')
ax.set_xticks(x)
ax.set_xticklabels(labels)
ax.legend()
plt.savefig(os.path.join(OUTPUT_DIR, "dt_reg_train_test_bar.png"))
plt.close()

print("3. Računam Permutation Importance...")

prep_step = dt_reg.named_steps['prep']
model_step = dt_reg.named_steps['model']
X_te_r_transformed = prep_step.transform(X_te_r)

perm_result = permutation_importance(model_step, X_te_r_transformed, y_te_r, n_repeats=10, random_state=42, n_jobs=-1)

feature_names_reg = num_cols_reg + list(prep_step.named_transformers_['cat'].get_feature_names_out(cat_cols_reg))

imp_df = pd.DataFrame({
    'feature': feature_names_reg,
    'importance_mean': perm_result.importances_mean,
    'importance_std': perm_result.importances_std
}).sort_values(by='importance_mean', ascending=False).head(10)

imp_df.to_csv(FILE_IMP_REG, index=False)

plt.figure(figsize=(10, 6))
plt.barh(imp_df['feature'], imp_df['importance_mean'], xerr=imp_df['importance_std'], color='skyblue')
plt.gca().invert_yaxis() # Najvažnija značajka na vrh
plt.title("Decision Tree Regressor - Permutation Importance")
plt.xlabel("Mean Decrease in Accuracy / R2")
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "dt_reg_importance.png"))
plt.close()

print("\n" + "="*50)
print("POKRETANJE KLASIFIKACIJSKE ANALIZE (Decision Tree)")
print("="*50)

dt_cls = Pipeline([('prep', prep_cls), ('model', DecisionTreeClassifier(random_state=42))])

print("1. Izvodim Stratified Cross-Validation...")
cv_cls = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
scoring_cls = ['accuracy', 'f1_macro']
scores_cls = cross_validate(dt_cls, X_cls, y_cls, cv=cv_cls, scoring=scoring_cls, n_jobs=-1)

cls_cv_data = {
    "model": "DecisionTree",
    "accuracy_mean": scores_cls['test_accuracy'].mean(),
    "accuracy_std": scores_cls['test_accuracy'].std(),
    "f1_mean": scores_cls['test_f1_macro'].mean(),
    "f1_std": scores_cls['test_f1_macro'].std()
}
append_to_csv(cls_cv_data, FILE_CV_CLS)

print("2. Izvodim Train/Test analizu...")
X_tr_c, X_te_c, y_tr_c, y_te_c = train_test_split(X_cls, y_cls, test_size=0.2, random_state=42, stratify=y_cls)
dt_cls.fit(X_tr_c, y_tr_c)

y_pred_tr_c = dt_cls.predict(X_tr_c)
y_pred_te_c = dt_cls.predict(X_te_c)

cls_tt_data = {
    "model": "DecisionTree",
    "train_accuracy": accuracy_score(y_tr_c, y_pred_tr_c),
    "test_accuracy": accuracy_score(y_te_c, y_pred_te_c),
    "train_f1": f1_score(y_tr_c, y_pred_tr_c, average='macro'),
    "test_f1": f1_score(y_te_c, y_pred_te_c, average='macro')
}
append_to_csv(cls_tt_data, FILE_TT_CLS)

fig, ax = plt.subplots(figsize=(10, 8))
ConfusionMatrixDisplay.from_estimator(dt_cls, X_te_c, y_te_c, normalize='true', cmap='Blues', ax=ax)
ax.set_title("Matrica Zabune - Decision Tree Classifier")
ax.grid(False)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "dt_cls_confusion_matrix.png"))
plt.close()

print("3. Računam Permutation Importance za klasifikaciju...")

prep_step_c = dt_cls.named_steps['prep']
model_step_c = dt_cls.named_steps['model']
X_te_c_transformed = prep_step_c.transform(X_te_c)

perm_result_c = permutation_importance(model_step_c, X_te_c_transformed, y_te_c, n_repeats=10, random_state=42, n_jobs=-1)

feature_names_cls = num_cols_cls + list(prep_step_c.named_transformers_['cat'].get_feature_names_out(cat_cols_cls))

imp_df_c = pd.DataFrame({
    'feature': feature_names_cls,
    'importance_mean': perm_result_c.importances_mean,
    'importance_std': perm_result_c.importances_std
}).sort_values(by='importance_mean', ascending=False).head(10)

imp_df_c.to_csv(FILE_IMP_CLS, index=False)

plt.figure(figsize=(10, 6))
plt.barh(imp_df_c['feature'], imp_df_c['importance_mean'], xerr=imp_df_c['importance_std'], color='lightgreen')
plt.gca().invert_yaxis()
plt.title("Decision Tree Classifier - Permutation Importance")
plt.xlabel("Mean Decrease in Accuracy")
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "dt_cls_importance.png"))
plt.close()

print("\n" + "="*50)
print(f"GOTOVO! Svi rezultati i slike nalaze se u mapi: {OUTPUT_DIR}")
print("Preuzmi datoteke iz lijeve bočne trake.")
print("="*50)

#ĆELIJA 2

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import os
from sklearn.inspection import PartialDependenceDisplay
from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.pipeline import Pipeline

sns.set_theme(style="whitegrid")
OUTPUT_DIR = "faza_3_rezultati"
os.makedirs(OUTPUT_DIR, exist_ok=True)

print("Učitavanje podataka...")
df = sns.load_dataset("diamonds")

print("Generiranje PDP grafova za KLASIFIKACIJU...")

X_cls = df.drop(columns=['cut'])
y_cls = df['cut']

cat_cols_cls = X_cls.select_dtypes(include=['category', 'object']).columns.tolist()
num_cols_cls = X_cls.select_dtypes(include=['number']).columns.tolist()

prep_cls = ColumnTransformer([
    ('num', 'passthrough', num_cols_cls),
    ('cat', OneHotEncoder(handle_unknown='ignore'), cat_cols_cls)
])

dt_cls_full = Pipeline([
    ('prep', prep_cls),
    ('model', DecisionTreeClassifier(max_depth=5, random_state=42))
])
dt_cls_full.fit(X_cls, y_cls)

classes = dt_cls_full.named_steps['model'].classes_
target_classes = ["Ideal", "Premium"]

for target_name in target_classes:
    if target_name in classes:
        fig, ax = plt.subplots(figsize=(8, 6))
        PartialDependenceDisplay.from_estimator(
            dt_cls_full,
            X_cls,
            features=["carat"],
            target=target_name,
            kind="average",
            ax=ax,
            line_kw={"color": "red", "linewidth": 2}
        )
        ax.set_title(f"PDP (Klasifikacija): Utjecaj 'carat' na klasu '{target_name}'")
        ax.set_ylabel(f"Vjerojatnost klase {target_name}")
        ax.set_xlabel("Carat (Težina)")

        filename = f"pdp_classification_{target_name}.png"
        plt.tight_layout()
        plt.savefig(os.path.join(OUTPUT_DIR, filename))
        plt.close()
        print(f"--> Spremljen: {filename}")

print("Generiranje PDP grafa za REGRESIJU (Carat vs Price)...")

X_reg = df.drop(columns=['price'])
y_reg = df['price']

cat_cols_reg = X_reg.select_dtypes(include=['category', 'object']).columns.tolist()
num_cols_reg = X_reg.select_dtypes(include=['number']).columns.tolist()

prep_reg = ColumnTransformer([
    ('num', 'passthrough', num_cols_reg),
    ('cat', OneHotEncoder(handle_unknown='ignore'), cat_cols_reg)
])

dt_reg_full = Pipeline([
    ('prep', prep_reg),
    ('model', DecisionTreeRegressor(max_depth=5, random_state=42))
])
dt_reg_full.fit(X_reg, y_reg)

fig, ax = plt.subplots(figsize=(8, 6))
PartialDependenceDisplay.from_estimator(
    dt_reg_full,
    X_reg,
    features=["carat"],
    kind="average",
    ax=ax,
    line_kw={"color": "#1f77b4", "linewidth": 2}
)

ax.set_title("PDP (Regresija): Utjecaj 'carat' na 'price'")
ax.set_ylabel("Predviđena cijena (Price)")
ax.set_xlabel("Carat (Težina)")

filename_reg = "pdp_regression_price_carat.png"
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, filename_reg))
plt.close()
print(f"--> Spremljen: {filename_reg}")

print("\nGeneriranje Scatter plotova (Train vs Test)...")

dt_reg.fit(X_tr_r, y_tr_r)

y_pred_train = dt_reg.predict(X_tr_r)
y_pred_test = dt_reg.predict(X_te_r)

fig, axes = plt.subplots(1, 2, figsize=(16, 7))

sns.scatterplot(x=y_tr_r, y=y_pred_train, ax=axes[0], alpha=0.2, color="#1f77b4")

min_val_tr = min(y_tr_r.min(), y_pred_train.min())
max_val_tr = max(y_tr_r.max(), y_pred_train.max())
axes[0].plot([min_val_tr, max_val_tr], [min_val_tr, max_val_tr], 'r--', lw=2, label="Idealno")

axes[0].set_title(f"TRAIN Set (R2={r2_score(y_tr_r, y_pred_train):.3f})")
axes[0].set_xlabel("Stvarna cijena ($)")
axes[0].set_ylabel("Predviđena cijena ($)")
axes[0].legend()
axes[0].grid(True, linestyle='--', alpha=0.6)

sns.scatterplot(x=y_te_r, y=y_pred_test, ax=axes[1], alpha=0.2, color="#ff7f0e")

min_val_te = min(y_te_r.min(), y_pred_test.min())
max_val_te = max(y_te_r.max(), y_pred_test.max())
axes[1].plot([min_val_te, max_val_te], [min_val_te, max_val_te], 'r--', lw=2, label="Idealno")

axes[1].set_title(f"TEST Set (R2={r2_score(y_te_r, y_pred_test):.3f})")
axes[1].set_xlabel("Stvarna cijena ($)")
axes[1].set_ylabel("Predviđena cijena ($)")
axes[1].legend()
axes[1].grid(True, linestyle='--', alpha=0.6)

plt.suptitle("Analiza preciznosti: Stvarne vs. Predviđene vrijednosti (Decision Tree)", fontsize=16)
plt.tight_layout()

filename_scatter = "dt_reg_scatter_train_test.png"
plt.savefig(os.path.join(OUTPUT_DIR, filename_scatter))
plt.close()
print(f"--> Spremljen graf: {filename_scatter}")

print("\nGeneriranje grafova za metrike...")

metrics_file = os.path.join(OUTPUT_DIR, "results_cv_metric.csv")

if os.path.exists(metrics_file):
    df_metrics = pd.read_csv(metrics_file)
    df_metrics = df_metrics.drop_duplicates(subset=["model"], keep="last")

    metrics_config = [
        ("rmse_mean", "RMSE (Root Mean Squared Error)", "RMSE (manje je bolje)", "dt_metric_rmse.png", "skyblue"),
        ("mae_mean", "MAE (Mean Absolute Error)", "MAE (manje je bolje)", "dt_metric_mae.png", "lightgreen"),
        ("r2_mean", "R2 (Koeficijent determinacije)", "R2 (više je bolje)", "dt_metric_r2.png", "salmon")
    ]

    for col_name, title, ylabel, filename, color in metrics_config:
        plt.figure(figsize=(6, 6))

        bars = plt.bar(df_metrics["model"], df_metrics[col_name], color=color, edgecolor='black', width=0.5)

        for bar in bars:
            yval = bar.get_height()
            plt.text(bar.get_x() + bar.get_width()/2, yval, f"{yval:.4f}", va='bottom', ha='center', fontsize=12, fontweight='bold')

        plt.title(title, fontsize=14)
        plt.ylabel(ylabel, fontsize=12)
        plt.grid(axis='y', linestyle='--', alpha=0.7)

        save_path = os.path.join(OUTPUT_DIR, filename)
        plt.tight_layout()
        plt.savefig(save_path, dpi=150)
        plt.close()
        print(f"--> Spremljen graf metrike: {filename}")

else:
    print(f"GREŠKA: Nije pronađena datoteka {metrics_file}. Prvo pokreni kod za regresiju iz prethodnog koraka.")

print("\n" + "="*50)
print(f"Sve slike su spremne u mapi: {OUTPUT_DIR}")
print("="*50)

# ĆELIJA 3

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import os

from sklearn.model_selection import train_test_split, cross_validate, KFold, StratifiedKFold
from sklearn.tree import DecisionTreeRegressor, DecisionTreeClassifier, plot_tree
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.metrics import accuracy_score, f1_score, ConfusionMatrixDisplay
from sklearn.inspection import permutation_importance, PartialDependenceDisplay

sns.set_theme(style="whitegrid")
OUTPUT_DIR = "faza_3_rezultati"
os.makedirs(OUTPUT_DIR, exist_ok=True)

print("Učitavanje podataka...")
df = sns.load_dataset("diamonds")

print("\n--- 1. REGRESIJSKO STABLO ---")

X_reg = df.drop(columns=['price'])
y_reg = df['price']

cat_cols_reg = X_reg.select_dtypes(include=['category', 'object']).columns.tolist()
num_cols_reg = X_reg.select_dtypes(include=['number']).columns.tolist()

prep_reg = ColumnTransformer([
    ('num', 'passthrough', num_cols_reg),
    ('cat', OneHotEncoder(handle_unknown='ignore'), cat_cols_reg)
])

X_tr_r, X_te_r, y_tr_r, y_te_r = train_test_split(X_reg, y_reg, test_size=0.2, random_state=42)

dt_reg = Pipeline([('prep', prep_reg), ('model', DecisionTreeRegressor(random_state=42))])
dt_reg.fit(X_tr_r, y_tr_r)

dt_viz = Pipeline([('prep', prep_reg), ('model', DecisionTreeRegressor(max_depth=3, random_state=42))])
dt_viz.fit(X_tr_r, y_tr_r)
plt.figure(figsize=(20, 8))
ft_names = num_cols_reg + list(dt_viz.named_steps['prep'].named_transformers_['cat'].get_feature_names_out(cat_cols_reg))
plot_tree(dt_viz.named_steps['model'], feature_names=ft_names, filled=True, fontsize=10, precision=0)
plt.title("Struktura Regresijskog Stabla (dubina 3)")
plt.savefig(os.path.join(OUTPUT_DIR, "dt_reg_structure.png"))
plt.close()

y_pred_tr = dt_reg.predict(X_tr_r)
y_pred_te = dt_reg.predict(X_te_r)

metrics = {
    "RMSE": (np.sqrt(mean_squared_error(y_tr_r, y_pred_tr)), np.sqrt(mean_squared_error(y_te_r, y_pred_te))),
    "R2": (r2_score(y_tr_r, y_pred_tr), r2_score(y_te_r, y_pred_te))
}

fig, axes = plt.subplots(1, 2, figsize=(12, 5))
for i, (name, (tr, te)) in enumerate(metrics.items()):
    axes[i].bar(['Train', 'Test'], [tr, te], color=['skyblue', 'salmon'])
    axes[i].set_title(f"{name} (Train vs Test)")
    axes[i].text(0, tr, f"{tr:.2f}", ha='center', va='bottom', fontweight='bold')
    axes[i].text(1, te, f"{te:.2f}", ha='center', va='bottom', fontweight='bold')

plt.suptitle("Analiza Overfittinga (Decision Tree Regressor)")
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "dt_reg_overfitting.png"))
plt.close()

plt.figure(figsize=(8, 6))
sns.scatterplot(x=y_te_r, y=y_pred_te, alpha=0.3, color="purple")
plt.plot([0, 20000], [0, 20000], 'r--', lw=2, label="Idealno")
plt.xlabel("Stvarna cijena")
plt.ylabel("Predviđena cijena")
plt.title("Scatter Plot: Točnost predikcije na Test setu")
plt.legend()
plt.savefig(os.path.join(OUTPUT_DIR, "dt_reg_scatter.png"))
plt.close()

X_te_r_trans = dt_reg.named_steps['prep'].transform(X_te_r)
perm_r = permutation_importance(dt_reg.named_steps['model'], X_te_r_trans, y_te_r, n_repeats=5, random_state=42, n_jobs=-1)

imp_df_r = pd.DataFrame({'feature': ft_names, 'importance': perm_r.importances_mean}).sort_values('importance', ascending=False).head(10)

plt.figure(figsize=(10, 6))
sns.barplot(x='importance', y='feature', data=imp_df_r, palette='viridis')
plt.title("Važnost značajki - Regresija (Cijena)")
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "dt_reg_importance.png"))
plt.close()

fig, ax = plt.subplots(figsize=(8, 6))
PartialDependenceDisplay.from_estimator(dt_reg, X_tr_r, features=["carat"], kind="average", ax=ax, line_kw={"color": "blue"})
ax.set_title("PDP: Utjecaj karataže na Cijenu")
plt.savefig(os.path.join(OUTPUT_DIR, "dt_reg_pdp_carat.png"))
plt.close()

print("\n--- 2. KLASIFIKACIJSKO STABLO ---")

X_cls = df.drop(columns=['cut'])
y_cls = df['cut']
cat_cols_cls = X_cls.select_dtypes(include=['category', 'object']).columns.tolist()
num_cols_cls = X_cls.select_dtypes(include=['number']).columns.tolist()

prep_cls = ColumnTransformer([
    ('num', 'passthrough', num_cols_cls),
    ('cat', OneHotEncoder(handle_unknown='ignore'), cat_cols_cls)
])

X_tr_c, X_te_c, y_tr_c, y_te_c = train_test_split(X_cls, y_cls, test_size=0.2, random_state=42, stratify=y_cls)

dt_cls = Pipeline([('prep', prep_cls), ('model', DecisionTreeClassifier(random_state=42))])
dt_cls.fit(X_tr_c, y_tr_c)

fig, ax = plt.subplots(figsize=(8, 6))
ConfusionMatrixDisplay.from_estimator(dt_cls, X_te_c, y_te_c, normalize='true', cmap='Blues', ax=ax)
ax.set_title("Matrica Zabune - Klasifikacija Reza")
ax.grid(False)
plt.savefig(os.path.join(OUTPUT_DIR, "dt_cls_confusion.png"))
plt.close()

ft_names_c = num_cols_cls + list(dt_cls.named_steps['prep'].named_transformers_['cat'].get_feature_names_out(cat_cols_cls))
X_te_c_trans = dt_cls.named_steps['prep'].transform(X_te_c)
perm_c = permutation_importance(dt_cls.named_steps['model'], X_te_c_trans, y_te_c, n_repeats=5, random_state=42, n_jobs=-1)

imp_df_c = pd.DataFrame({'feature': ft_names_c, 'importance': perm_c.importances_mean}).sort_values('importance', ascending=False).head(10)

plt.figure(figsize=(10, 6))
sns.barplot(x='importance', y='feature', data=imp_df_c, palette='magma')
plt.title("Važnost značajki - Klasifikacija (Rez)")
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "dt_cls_importance.png"))
plt.close()

fig, ax = plt.subplots(figsize=(8, 6))
PartialDependenceDisplay.from_estimator(dt_cls, X_tr_c, features=["carat"], target="Ideal", kind="average", ax=ax, line_kw={"color": "green"})
ax.set_title("PDP: Utjecaj karataže na klasu 'Ideal'")
plt.savefig(os.path.join(OUTPUT_DIR, "dt_cls_pdp_ideal.png"))
plt.close()

print(f"\nGotovo! Sve slike su u mapi: {OUTPUT_DIR}")
